<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">

	<META NAME="GENERATOR" Content="Visual Page 2.0 for Windows">
	<TITLE>Name</TITLE>
</HEAD>

<BODY>

<P>
<TABLE BORDER="1" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<TD VALIGN="TOP"><B>Name</B></TD>
		<TD VALIGN="TOP"><B>Synopsis</B></TD>
		<TD VALIGN="TOP"><B>Context</B></TD>
		<TD VALIGN="TOP"><B>Forces</B></TD>
		<TD VALIGN="TOP"><B>Solution</B></TD>
		<TD VALIGN="TOP"><B>Consequences</B></TD>
		<TD VALIGN="TOP"><B>Examples</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Fundamental</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Delegation</TD>
		<TD VALIGN="TOP">using instances of other classes instead of inheritance</TD>
		<TD VALIGN="TOP">is-a-role-played-by, instead of is-a-kind-of - e.g. Person who can be MD, patient, etc. - inheritance is static
			- so can’t change roles</TD>
		<TD VALIGN="TOP">&middot; object wants to change subclass-type over time <BR>
			&middot; object wants to hide inherited method or variable <BR>
			&middot; extending utility class (Vector) - next JDK? - trouble if change utility class, loss of encapsulation</TD>
		<TD VALIGN="TOP">Delegator - new class that instantiates and uses methods of original class. More general purpose than inheritance</TD>
		<TD VALIGN="TOP">&middot; can’t see connections, as in inheritance <BR>
			&middot; call it widgetFactory <BR>
			&middot; don’t mix direct and indirect delegation</TD>
		<TD VALIGN="TOP">Event listeners [GSRF]</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Interface</TD>
		<TD VALIGN="TOP">enforce modularity without multiple inheritance</TD>
		<TD VALIGN="TOP">object can call common methods of related objects without knowing exact object type</TD>
		<TD VALIGN="TOP">&middot; eliminate assumption that used object must be of a certain class <BR>
			&middot; limit dependencies <BR>
			&middot; enabled indirect relationships</TD>
		<TD VALIGN="TOP"><B>Client</B> uses IndirectionIF <BR>
			<B>IndirectionIF</B> interface <BR>
			<B>Service</B> provided to Client via IF</TD>
		<TD VALIGN="TOP">&middot; can make more obtuse, but increases reuse potential</TD>
		<TD VALIGN="TOP">java.io.FilenameFilter</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Immutable</TD>
		<TD VALIGN="TOP">avoids need for synchronization</TD>
		<TD VALIGN="TOP">rather than changing an object, make a new one with new properties, and point to it</TD>
		<TD VALIGN="TOP">&middot; passive instances (don’t change own state) - used by multiple other objects <BR>
			&middot; coordinating state changes - e.g. alerting listeners, can be bug prone <BR>
			&middot; multiple threads access the object <BR>
			&middot; overhead of synchronization too high</TD>
		<TD VALIGN="TOP">&middot; class with no set methods - only constructor and gets <BR>
			&middot; no need for final variables <BR>
			&middot; ReadOnlyIF - rather than new class, protect how methods can be accessed</TD>
		<TD VALIGN="TOP">&middot; never changes <BR>
			&middot; no need to synchronize <BR>
			&middot; operations that would have had to change state create new instead</TD>
		<TD VALIGN="TOP">String</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Marker Interface</TD>
		<TD VALIGN="TOP">indicates semantic class - used in utility classes</TD>
		<TD VALIGN="TOP">e.g. == faster than <I>equals</I> if EqualsByIdentity works - so mark as such</TD>
		<TD VALIGN="TOP">&middot; utility class needs to know intended use without knowing type of class</TD>
		<TD VALIGN="TOP"><B>MarkerIF</B> that declares no methods or variables</TD>
		<TD VALIGN="TOP">utility class recognizes MarkerIF without knowing type of class</TD>
		<TD VALIGN="TOP">Serializable</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Proxy</TD>
		<TD VALIGN="TOP">forces indirection without client being aware</TD>
		<TD VALIGN="TOP">allows transparent management of another objects services <B>remote proxy</B> - RMI <B>access proxy</B> - load
			balancing behind scenes <B>virtual proxy</B> - access before object exists</TD>
		<TD VALIGN="TOP">&middot; not possible to provide service immediately <BR>
			&middot; hide complexity of gaining visibility to an object <BR>
			&middot; control access to object without intertwining service and access-control <BR>
			&middot; make access to service by client as transparent as possible</TD>
		<TD VALIGN="TOP"><B>AbstractService </B>or <B>ServiceIF <BR>
			Service <BR>
			ServiceProxy</B></TD>
		<TD VALIGN="TOP">&middot; only useful if Proxy does additional management <BR>
			&middot; management of Service is transparent to both Service objects and their clients</TD>
		<TD VALIGN="TOP">ReferenceCountedHashtable -only clones itself for copy if multiple simultaneous access [virtual proxy to evidence
			- will collect it if needed behind the scenes]</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Creational</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Factory Method</TD>
		<TD VALIGN="TOP">reuse a class with arbitrary data type - delegate choice of object to another object, access via interface</TD>
		<TD VALIGN="TOP">instantiate classes while remaining independent of the classes it creates</TD>
		<TD VALIGN="TOP">&middot; want to create objects with a common interface without knowing what classes are available <BR>
			&middot; allows set of creatable classes to be dynamically extended</TD>
		<TD VALIGN="TOP"><B>Product</B> - abstract superclass <B><BR>
			Concrete Product</B> - instance <BR>
			<B>Creation Requester</B> via IF <B><BR>
			FactoryIF</B> - createImage <B><BR>
			Factory</B> implements IF to make Concrete Products</TD>
		<TD VALIGN="TOP">&middot; creation requester is independent of concrete products created <BR>
			&middot; set of classes to create can change dynamically</TD>
		<TD VALIGN="TOP">URLConnection:getContent is creation requester; ContextHandler is Product; ContextHandlerFactory</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Abstract Factory (Toolkit)</TD>
		<TD VALIGN="TOP">create instances of abstract classes from matched set of concrete subclasses (e.g. differing windowing systems)</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; common interface to multiple products <BR>
			&middot; enforce constraint that all concrete classes belong to same product</TD>
		<TD VALIGN="TOP"><B>Client</B> - use abstract widgets <B>AbstractFactory</B> - abstract methods to create widgets; static getFactory()
			method. <B>ConcreteFactory 1-n <BR>
			AbstractWidet 1-n <BR>
			ConcreteWidget 1-n</B></TD>
		<TD VALIGN="TOP">&middot; concrete widgets independent of classes that make and use them. <BR>
			&middot; ensures consistent widgets <BR>
			&middot; much work to create all <BR>
			&middot; may need Bridge if want hierarchy too</TD>
		<TD VALIGN="TOP">java.awt.Toolkit</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Builder</TD>
		<TD VALIGN="TOP">client builds complex object by specifying type and content. Shielded from details of construction</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; many representations of same data <BR>
			&middot; content providers independent of external data representation</TD>
		<TD VALIGN="TOP"><B>Product </B>- data representation <B><BR>
			ProductIF <BR>
			Client</B> - getInstance(type), build(), getProduct() <B><BR>
			ConcreteBuilder <BR>
			AbstractBuilder </B>- getInstance(type), getProduct() <BR>
			<B>Director </B>- calls build1-n()</TD>
		<TD VALIGN="TOP">&middot; finer control over construction than Factory, since Director has step-by-step control over creation</TD>
		<TD VALIGN="TOP">MIMEParser <BR>
			&middot; Related to:<B> </B>Interface, Composite, Factory, Layered Initialization, Marker, Null, Visitor</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Prototype</TD>
		<TD VALIGN="TOP">make customized objects by cloning them</TD>
		<TD VALIGN="TOP">CAD support for novel, composite objects</TD>
		<TD VALIGN="TOP">&middot; create objects without knowing their exact class, how they are created, or data contained <BR>
			&middot; new classes not known until runtime <BR>
			&middot; bad solutions include: <BR>
			&middot; initiator = creator <BR>
			&middot; Factory - becomes huge <BR>
			&middot; AbstractFactory - even larger</TD>
		<TD VALIGN="TOP"><B>Client</B> - registerPrototype() <B><BR>
			Prototype</B> - are cloned <B><BR>
			PrototypeBuilder </B>- also registers prototype <B>PrototypeIF</B> - [optional] Cloning - shallow (copy) vs. deep
			(new instance) - avoid circular references.</TD>
		<TD VALIGN="TOP">&middot; dynamically add/remove prototypes at runtime <BR>
			&middot; PrototypeBuilder encapsulates details of contruction <BR>
			&middot; have to write many PrototypeBuilder classes <BR>
			&middot; no need to create hierarchy</TD>
		<TD VALIGN="TOP">JavaBeans - saved to file, so time-delayed cloning</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Singleton</TD>
		<TD VALIGN="TOP">ensures only one instance created</TD>
		<TD VALIGN="TOP">error counters, DB connection managers, audio manager</TD>
		<TD VALIGN="TOP">&middot; exactly one instance <BR>
			&middot; accessible to all clients</TD>
		<TD VALIGN="TOP">private constructors, static singletonInstance; static getInstance()</TD>
		<TD VALIGN="TOP">&middot; exactly one instance <BR>
			&middot; subclassing a problem, since static methods are final <BR>
			&middot; ObjectPreserver (Runnable) with preserveObject(o) can prevent unexpected GC</TD>
		<TD VALIGN="TOP">java.lang.Runtime</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Object Pool</TD>
		<TD VALIGN="TOP">reuse expensive objects</TD>
		<TD VALIGN="TOP">DB connections</TD>
		<TD VALIGN="TOP">&middot; limit the number instances of a class <BR>
			&middot; reuse expensive instances, rather than GC <BR>
			&middot; assumes that each instance is interchangeable</TD>
		<TD VALIGN="TOP"><B>Reusable</B> - dynamically used <BR>
			<B>Client</B> - use Reusables. releaseReusable() when done <B><BR>
			ReusablePool</B> - singleton. acquiteReusable() to get.</TD>
		<TD VALIGN="TOP">&middot; can have limited pool, but unlimited creation - extras GCed after peak usage</TD>
		<TD VALIGN="TOP">ConnectionPool <BR>
			&middot; Cache - reuses specific instances <BR>
			&middot; Factory encapsulates creation, but no reuse</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Partitioning</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Layered Initialization</TD>
		<TD VALIGN="TOP">when common logic used to decide which subclass to create</TD>
		<TD VALIGN="TOP">separate logic for getting info from database from rules to retrieve data - e.g. parse query to decide which DB
			API to use</TD>
		<TD VALIGN="TOP">&middot; specialized class need to process complex data <BR>
			&middot; encapsulate logic for choosing this class <BR>
			&middot; constructors invoked after decide which class <BR>
			&middot; one portal to object that decides upon class <BR>
			&middot; decouples DB access from decider</TD>
		<TD VALIGN="TOP"><B>Service</B> - only that are public, encapulates common logic, delegates specialized logic<BR>
			<B>ServiceImplIF <BR>
			ServiceImplFactoryIF</B> - [optional]<BR>
			<B>ServiceImplFactory <BR>
			ServiceImpl</B></TD>
		<TD VALIGN="TOP">&middot; complexity of initialization hidden from client <BR>
			&middot; only dependencies are to Service objects <BR>
			&middot; can link several layers - each Impl can be a Service</TD>
		<TD VALIGN="TOP">java.net.URL</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Filter</TD>
		<TD VALIGN="TOP">dynamically connect and apply operations to streams</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; reuse common data transformations <BR>
			&middot; dynamically combine them <BR>
			&middot; use of transformations transparent to outside</TD>
		<TD VALIGN="TOP"><B>AbstractSource</B> - getData(), putData() <B>ConcreteSource - </B>provider <B>AbstractSourceFilter ConcreteSourceFilter
			<BR>
			AbstractSink ConcreteSink AbstractSinkFilter <BR>
			ConcreteSinkFilter</B></TD>
		<TD VALIGN="TOP">&middot; filters that don’t maintain state can be dynamically replaced at runtime</TD>
		<TD VALIGN="TOP">java.io.FilterReader - source java.io.FilterWriter - sink Pipes</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Composite (Recursive Composition)</TD>
		<TD VALIGN="TOP">build complex objects by recursing over tree of sub-objects</TD>
		<TD VALIGN="TOP">elements of a document</TD>
		<TD VALIGN="TOP">&middot; complex object decomposed into part-whole hierarchy <BR>
			&middot; minimize number of kinds of child objects that tree must be aware of</TD>
		<TD VALIGN="TOP">Abstract superclass for all objects and all composites<BR>
			<B>AbstractComponent<BR>
			ConcreteComponent <BR>
			AbstractComposite <BR>
			ConcreteComposite</B></TD>
		<TD VALIGN="TOP">&middot; composites can contain components or other composites <BR>
			&middot; can put n/a methods in high-level class (violating High Cohesion) to increase simplicity <BR>
			&middot; can cache info gather through delegation, but need changeNotification()</TD>
		<TD VALIGN="TOP">javax.swing.JComponent javax.swing.JContainer</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Structural</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Adapter</TD>
		<TD VALIGN="TOP">provide access to known interface without having to know details of class instance. Connects clients with <I>one</I>
			object not known to client</TD>
		<TD VALIGN="TOP">Adapt a class not designed to use an interface to pretend to use that interface</TD>
		<TD VALIGN="TOP">&middot; use interface methods on a class that doesn’t implement that interface - e.g. don’t have source code,
			or sufficiently general purpose that shouldn’t implement that interface directly <BR>
			&middot; need to dynamically determine linkages between methods</TD>
		<TD VALIGN="TOP"><B>Client</B> - calls interface <B><BR>
			TargetIF</B> <B>Adapter</B> - implements TargetIF, delegates to Adaptee, possibly with translation<BR>
			<B>Adaptee</B> - does not implement TargetIF</TD>
		<TD VALIGN="TOP">&middot; Client and Adaptee independent <BR>
			&middot; extra level of indirection can be confusing Which Adaptee instance should be called? <BR>
			&middot; pass Client reference to Adapter <BR>
			&middot; Adapter inner class of Adaptee</TD>
		<TD VALIGN="TOP">&middot; Java event handling: with anonymous classes: addActionListener(new ActionListener() { public void actionPerformed(ActionEvent
			evt) { close(); }}); <BR>
			&middot; xref: (Fa&ccedil;ade, Iterator, Proxy, Strategy)</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Iterator</TD>
		<TD VALIGN="TOP">sequentially access objects without knowing type</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; access contents without dependency upon collection <BR>
			&middot; uniform way to access contents of many collections</TD>
		<TD VALIGN="TOP"><B>Collection <BR>
			IteratorIF </B>- methods used by collection <B>Iterator</B> <B><BR>
			CollectionIF</B> - consistent way for Collection to create Iterator</TD>
		<TD VALIGN="TOP">&middot; multiple iterators allows concurrent read-only access <BR>
			&middot; iterator subclasses can use different means of traversing (e.g. SQL results) <BR>
			&middot; protects against null results</TD>
		<TD VALIGN="TOP">java.util.Iterator/Collection <BR>
			&middot; Adapter - iterator is one <BR>
			&middot; Factory - can be used to choose an iterator <BR>
			&middot; Null Object - null iterators are one</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Bridge</TD>
		<TD VALIGN="TOP">classes representing abstract hierarchy separate from hierarchy implementing the functionality</TD>
		<TD VALIGN="TOP">control sensors of 2 mfgs: <BR>
			&middot; scale = single <BR>
			&middot; speed = time-average <BR>
			&middot; location = stream -make hierarchy of interfaces and impls.</TD>
		<TD VALIGN="TOP">&middot; avoid combining hierarchies of abstractions and implementations <BR>
			&middot; reuse logic common to abstraction <BR>
			&middot; extend the logic of abstraction with one new class rather than one for each combination of base abstraction
			and implementation <BR>
			&middot; multiple abstractions can share same implementation</TD>
		<TD VALIGN="TOP"><B>Abstraction</B> - top level - uses: <B>AbstractionImpl</B> - IF <B>SpecializedAbstraction</B> subclass of Abstraction
			using: <B>SpecializedAbstractionImpl </B>with parallel hierarchies <BR>
			<B>Impl1,2</B> at top level <B><BR>
			SpecializedImpl1,2</B></TD>
		<TD VALIGN="TOP">&middot; <I>Many implementations?</I> use AbstractFactory, to delegate creation of implementation, else direct.
			<BR>
			&middot; <I>Changing implementation over time?</I> logic for changing either in Abstraction, or Decorator</TD>
		<TD VALIGN="TOP">java.awt.Component/Button/List vs. java.awt.peer. Component uses AbstractFactory (awt.Toolkit). Actions common
			to Component delegated to appropriate Peer <BR>
			&middot; Layered Architecture Analysis</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Fa&ccedil;ade</TD>
		<TD VALIGN="TOP">Connects clients to<I> a set</I> of objects via a single object interface</TD>
		<TD VALIGN="TOP">protect client from complexity of implementation</TD>
		<TD VALIGN="TOP">&middot; many dependencies among classes implementing an abstraction <BR>
			&middot; simplify client classes <BR>
			&middot; move abstraction from client to fa&ccedil;ade <BR>
			&middot; doesn’t need to be only way to access internals - just default</TD>
		<TD VALIGN="TOP">collect abstraction into single class, then have client call its methods. Akin to Interface</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">java.net.URL <BR>
			&middot; Interface - can further refine fa&ccedil;ade access <BR>
			&middot; Don’t Talk to Strangers - often leads to many facades</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Flyweight</TD>
		<TD VALIGN="TOP">reduce memory usage by re-using instances multiple places</TD>
		<TD VALIGN="TOP">e.g. one instance per DocChar</TD>
		<TD VALIGN="TOP">&middot; only when identity of each object not needed <BR>
			&middot; reduce large number of similar to few shared unique ones. <BR>
			&middot; extrinsic attributes can increase sharing</TD>
		<TD VALIGN="TOP"><B>AbstractFlyweight</B> - superclass, common logic <B><BR>
			SharedConcreteFlyweight</B> - any intrinsic state must be sharable <B>UnsharedConcreteFlyweight</B> <BR>
			<B>FlyweightFactory</B> - provides AbstractFlyweight, creating sharable or unsharable as appropriate <BR>
			<B>Client</B> - use flyweights</TD>
		<TD VALIGN="TOP">&middot; decreases memory, but slows runtime <BR>
			&middot; extrinsic attributes are slower to access <BR>
			&middot; adds complexity, so only use these if needed</TD>
		<TD VALIGN="TOP">java.lang.String <BR>
			&middot; Composite for representing leaf nodes <BR>
			&middot; Immutables - often used <BR>
			&middot; Factory - also used</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Dynamic Linkage</TD>
		<TD VALIGN="TOP">load, upon request, arbitrary classes using known interface</TD>
		<TD VALIGN="TOP">e.g. food processor</TD>
		<TD VALIGN="TOP">&middot; load and use arbitrary classes of which has no prior knowledge <BR>
			&middot; loaded classes must call back to programs which loaded it</TD>
		<TD VALIGN="TOP"><B>EnvironmentIF</B> <B>Environment</B> - loads ConcreteLoadables with IF<BR>
			<B>AbstractLoadableClass </B>setEnvironment(:EnvIF); start(); to run loaded class <B><BR>
			ConcreteLoadableClass</B> - has references to Environment</TD>
		<TD VALIGN="TOP">&middot; AbstractLoadable subclasses loaded at runtime <BR>
			&middot; environment and loaded class don’t need to know each other <BR>
			&middot; increases load time</TD>
		<TD VALIGN="TOP">web browsers; Applet via AppletStub <BR>
			&middot; Virtual Proxy</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Virtual Proxy</TD>
		<TD VALIGN="TOP">postpone creation of expensive object until clear that needed - hide fact that may not exist: Lazy instantiation</TD>
		<TD VALIGN="TOP">e.g. large applet - load as needed. No static references to class for which proxy, so not immediately loaded</TD>
		<TD VALIGN="TOP">&middot; time consuming and potentially not necessary to implement a class <BR>
			&middot; delayed instantiation must be done transparently</TD>
		<TD VALIGN="TOP"><B>Service</B> top level logic, creates helpers<BR>
			<B>Client</B> works via Proxy <BR>
			<B>ServiceProxy</B> - loads the class via Class.forName() <BR>
			<B>ServiceIF</B> - static references to this, so Service not loaded</TD>
		<TD VALIGN="TOP">&middot; classes loaded when needed <BR>
			&middot; all access must be via IF <BR>
			&middot; don’t need to know whether class is loaded <BR>
			&middot; put Service within package to make proxy role explicit <BR>
			&middot; use clazz.getConstructor()</TD>
		<TD VALIGN="TOP">&middot; Fa&ccedil;ade can limit number of Virtual Proxies needed <BR>
			&middot; Double Checked Locking - ensure that only one instance created without using synchronization</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Decorator (Wrapper)</TD>
		<TD VALIGN="TOP">extends functionality in way transparent to clients by using instance of subclass of original class that delegates
			operations to the original object</TD>
		<TD VALIGN="TOP">e.g. security monitors/cameras</TD>
		<TD VALIGN="TOP">&middot; need to extend functionality, but reasons not to use inheritance <BR>
			&middot; need to dynamically extend and withdrawal functionality from a class</TD>
		<TD VALIGN="TOP"><B>AbstractService</B> - class or interface to be extended <B><BR>
			ConcreteService</B> - <BR>
			<B>AbstractWrapper</B> - extends AbstractService; refer to ConcreteService for delegation <BR>
			<B>ConcreteWrapper1,2 </B><BR>
			&middot; iff one ConcreteService, then wrapper is subclass of it <BR>
			&middot; iff delegation to only one object, no need for wrapper <BR>
			&middot; iff one ConcreteWrapper, don’t need AbstractWrapper</TD>
		<TD VALIGN="TOP">&middot; wrappers allow dynamic grant/revoke behaviors, unlike inheritance, but more error prone <BR>
			&middot; fewer classes, but more objects <BR>
			&middot; hides objects behind wrappers, so can’t identify</TD>
		<TD VALIGN="TOP">&middot; Delegation - a Decorator <BR>
			&middot; Filter - Stream decorator <BR>
			&middot; Strategy - for flexibility in the middle of a method <BR>
			&middot; Template - also allows variability in middle</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Cache Management</TD>
		<TD VALIGN="TOP">fast access to expensive objects via reuse</TD>
		<TD VALIGN="TOP">database connections</TD>
		<TD VALIGN="TOP">&middot; access to objects taking long to construct <BR>
			&middot; need to set upper bound on number cached <BR>
			&middot; need to enforce upper bounds (e.g. ftp performance via number of connections)</TD>
		<TD VALIGN="TOP"><B>ObjectKey</B> identify content ob object to be fetched or created <B><BR>
			CacheManager</B> .fetchObject() to get a key <BR>
			<B>ObjectCreator</B> for new ones <BR>
			<B>Cache</B> has fetchObject() - if no keys in cache, call creator</TD>
		<TD VALIGN="TOP">&middot; using Virtual Proxy, can add caching to any program <BR>
			&middot; hard to get absolute read/write consistency between cache on offline source - can time expire for relative
			consistency</TD>
		<TD VALIGN="TOP">can prefetch objects into cache, like Apache <BR>
			&middot; Hashtable best speed for lookup <BR>
			&middot; removing least recently used is optimal - linked list</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Behavioral</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Chain of Responsibility</TD>
		<TD VALIGN="TOP">send a command without knowing which object(s) will receive it. Each member of chain decides whether or not to
			handle event</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>CommandSender</B><BR>
			<B>CommandHandlerIF</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">Java 1.0 event model - scrapped<BR>
			&middot; Composite - enpasulates chain of responsibility<BR>
			&middot; Command - makes responsibility explicity, unlike chain<BR>
			&middot; Template - organizing behavior</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Command</TD>
		<TD VALIGN="TOP">encapsulate command in object so can select, sequence, queue or undo them</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>AbstractCommand<BR>
			ConcreteCommand<BR>
			Invoker<BR>
			CommandManager</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">get/setActionCommand() for buttons to implement callback via Class.forName()<BR>
			&middot; Factory Method - indirection between UI and command<BR>
			&middot; Little Language - uses Commands<BR>
			&middot; Marker Interface - Undoable<BR>
			&middot; Snapshot - coarse Undo<BR>
			&middot; Template Method - top-level Undo logic</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Little Language / Interpreter</TD>
		<TD VALIGN="TOP">when don't want to use YACC&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Client<BR>
			LexialAnalyzer<BR>
			Parser<BR>
			AbstractNonTerminal<BR>
			ConcreteNonTerminal<BR>
			TerminalToken<BR>
			InputStream</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">java.text.Format<BR>
			&middot; Composite - for parse tree<BR>
			&middot; Visitor - to traverse parse tree</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Mediator</TD>
		<TD VALIGN="TOP">one object manages the state changes of other objects (rather than having them each manage own logic)&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Colleague1,2<BR>
			EventListener1,2<BR>
			Mediator</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">Jcomponent passing KeyEvents to FocusManager<BR>
			&middot; Adapter - to receive notification<BR>
			&middot; Interface - keeps Colleage independent of Mediator<BR>
			&middot; Observer - Java's delegation method<BR>
			&middot; Low Coupling / High Cohesion - an exception to this advice</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Snapshot</TD>
		<TD VALIGN="TOP">serialization or memento</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">[<I>Memento</I>]<B><BR>
			Originator</B> - createMemento()<BR>
			<B>Memento</B> - private static classes - saves state<BR>
			<B>MementoIF</B> - createMemento()<BR>
			<B>Caretaker</B> - maintain Memento objects<BR>
			[<I>Serialization</I>]<BR>
			<B>Target</B> - <BR>
			<B>ObjectOutputStream<BR>
			OutputStream<BR>
			ObjectInputStream</B></TD>
		<TD VALIGN="TOP">[<I>Memento</I>]<BR>
			best for partial state<BR>
			object identity preserved<BR>
			no overhead<BR>
			expertise not required<BR>
			[<I>Serialization</I>]<BR>
			best for whole state<BR>
			object identity lost (copies)<BR>
			high overhead<BR>
			can't recreate solo visitor</TD>
		<TD VALIGN="TOP">&middot; Command - undoing state changes</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Observer</TD>
		<TD VALIGN="TOP">dynamically register dependencies and notify dependent objects upon state change&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>ObserverIF<BR>
			Observer<BR>
			ObservableIF<BR>
			Observable<BR>
			Multicaster</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">Java AWTEventMulticaster<BR>
			&middot; Adapter - allows objects not implementing Observer pattern to play<BR>
			&middot; Delegation - used by Observer<BR>
			&middot; Mediator - coordinate state changes<BR>
			&middot; Publisher-Subscriber - reliable delivery notification</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">State</TD>
		<TD VALIGN="TOP">encapsulate state within an object&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Context<BR>
			ContextState<BR>
			ConcreteState</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; Flyweight - to share states<BR>
			&middot; Mediator - to manage states<BR>
			&middot; Singleton - non-parametric states</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Null Object</TD>
		<TD VALIGN="TOP">can call objects methods without having anything happen (rather than using null)</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Delegator<BR>
			AbstractOperation<BR>
			RealOperation<BR>
			NullOperation</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; Singleton - if lack instance-specific info<BR>
			&middot; Strategy - uses Null Object</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Strategy</TD>
		<TD VALIGN="TOP">encapsulate related algorithms in subclass of related superclass - allows varying strategy over time&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Client</B> - delegates op to Strategy<B><BR>
			AbstractStrategy<BR>
			ConcreteStrategy1,2</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">java.util.zip for Checksum type<BR>
			&middot; Adapter - lets client perform function in novel way, <I>vs</I> Strategy which provides novel way to act
			upon client<BR>
			&middot; Flyweight - often used<BR>
			&middot; Null Object<BR>
			&middot; Template Method - manage alternate behavior via subclassing rather than delegation</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Template</TD>
		<TD VALIGN="TOP">contains most of the logic needed for a process, but interchangeable abstract classes for portions</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>AbstractTemplate<BR>
			ConcreteTemplate</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; Strategy</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Visitor</TD>
		<TD VALIGN="TOP">put common logic in a class that is passed among other objects&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP"><B>Client<BR>
			ObjectStructure<BR>
			AbstractElement<BR>
			ConcreteElement1,2<BR>
			Visitor<BR>
			ConcreteVisitor1,2</B></TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&middot; Iterator<BR>
			&middot; Little Language<BR>
			&middot; Composite</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP" COLSPAN="7"><B>Concurrency</B></TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Single Threaded Execution</TD>
		<TD VALIGN="TOP">synchronized</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Guarded Suspension</TD>
		<TD VALIGN="TOP">defer execution until a condition is met&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Balking</TD>
		<TD VALIGN="TOP">don't execute code if object not in correct state&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Scheduler</TD>
		<TD VALIGN="TOP">pluggable scheduling policies for threads</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Read/Write Lock</TD>
		<TD VALIGN="TOP">allow concurrent read access but exclusive write access</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Producer-Consumer</TD>
		<TD VALIGN="TOP">coordinate asynchronous producing &amp; consuming&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">sockets</TD>
	</TR>
	<TR>
		<TD VALIGN="TOP">Two-Phase Termination</TD>
		<TD VALIGN="TOP">set latch to indicate shutdown request; check latch during shutdown</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
		<TD VALIGN="TOP">&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>GRASP Patterns</B></TD>
	</TR>
	<TR>
		<TD>Controller</TD>
		<TD>decouple event source from objects that handle event</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Creator</TD>
		<TD>delegate to various constructors</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Expert</TD>
		<TD>assign responsibility to class that has needed knowledge</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Law of Demeter (Don't talk to strangers)</TD>
		<TD>use interfaces to enforce high-cohesion / low-coupling</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Low Coupling / High Cohesion</TD>
		<TD>reorganize brittle classes</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Polymorphism</TD>
		<TD>use class overloading rather than if statements</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Pure Fabrication</TD>
		<TD>create classes that don't reflect conceptual model if avoiding fictional classes results in high coupling</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>GUI Design Patterns</B></TD>
	</TR>
	<TR>
		<TD>Conversational Text</TD>
		<TD>NLP input</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Direct Manipulation</TD>
		<TD>GUI</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Disabled Irrelevant Things</TD>
		<TD>hide or disable N/A GUI elements</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Ephemeral Feedback</TD>
		<TD>provide status information without interrupting workflow</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Explorable Interface</TD>
		<TD>allow undo</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Form</TD>
		<TD>organize multi-step process in structured manner</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Interaction Style</TD>
		<TD>match GUI to user's needs (accessibility)</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Limited Selection Size</TD>
		<TD>avoid displaying more than a limited number of selections at a time</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Selection</TD>
		<TD>pick lists</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Step-by-Step Instructions</TD>
		<TD>demo - GUI shows user what to do</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Supplementary Window</TD>
		<TD>dialog</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Window Per Task</TD>
		<TD>organize components of a cohesive task in one location</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>Organizational Coding Patterns</B></TD>
	</TR>
	<TR>
		<TD>Accessor Method Name</TD>
		<TD>understandable naming schema conforming to JavaBeans spec</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Anonymous Adapter</TD>
		<TD>for callbacks like close window on exit</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Checked vs. Unchecked Exceptions</TD>
		<TD>explicitly catch and handle all expected, recoverable exceptions</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Client Socket</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Composed Method</TD>
		<TD>subdivide large methods</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Conditional Compilation</TD>
		<TD>javac ignores if(false) blocks, so use global constant for DEBUG</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Convert Exceptions</TD>
		<TD>convert exception names at domain boundaries</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Define Constants in Interfaces</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Extend Super</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Intention Revealing Method</TD>
		<TD>give methods meaningful names</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Server Socket</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Switch</TD>
		<TD>instead of if statements</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Symbolic Constant Names</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>Code Optimization Patterns</B></TD>
	</TR>
	<TR>
		<TD>Double Checked Locking</TD>
		<TD>prevent one thread from initializing a resource while another is part way through same task</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Hashed Adapter Objects</TD>
		<TD>fast lookup for method passing</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Lazy Initialization</TD>
		<TD>delay creation until needed, but make client think it already exists</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Lookup Table</TD>
		<TD>precompile expensive calculations and re-use them</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Loop Unrolling</TD>
		<TD>reduce number of loop iterations, increase work per iteration</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>Robustness Coding Patterns</B></TD>
	</TR>
	<TR>
		<TD>Assertion Testing</TD>
		<TD>verify contract by testing preconditions, postconditions, invariants, and data conditions at runtime</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Copy Mutable Parameters</TD>
		<TD>copy volatile objects before assessing their state (so that state doesn't change mid-assessment)</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Guaranteed Cleanup</TD>
		<TD>finally(), finalize()</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Maximize Privacy</TD>
		<TD>make members as private as possible</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Return New Objects from Accessor Methods</TD>
		<TD>objects that capture the state of a volatile object should be final or copies</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD COLSPAN="7"><B>Testing Patterns</B></TD>
	</TR>
	<TR>
		<TD>Acceptance Testing</TD>
		<TD>consumer testing of software</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Black Box Testing</TD>
		<TD>design tests based solely upon requirements (not implementation)</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Integration Testing</TD>
		<TD>when testing addition of new classes</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Regression Testing</TD>
		<TD>CVS test results so can see where bugs are introduced</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>System Testing</TD>
		<TD>beta testing</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>Unit Testing</TD>
		<TD>test individual classes in isolation</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
	<TR>
		<TD>White Box Testing</TD>
		<TD>exhaustive test of all possible execution paths</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
		<TD>&nbsp;</TD>
	</TR>
</TABLE>


</BODY>

</HTML>
