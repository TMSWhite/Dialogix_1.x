options {
    LOOKAHEAD=1;
//    STATIC=false;
}

PARSER_BEGIN(Qss)

public class Qss {
    static java.util.Stack stack = new java.util.Stack();
    static Evidence data;
    static String stringToken = null;
 
   public Qss() {
   }

	public boolean booleanVal(Evidence ev, String exp) {
		return parse(ev, exp).booleanVal();
	}
	
	public String StringVal(Evidence ev, String exp) {
		return parse(ev, exp).StringVal();
	}
	
	public double doubleVal(Evidence ev, String exp) {
		return parse(ev, exp).doubleVal();
	}
	
	public long longVal(Evidence ev, String exp) {
		return parse(ev, exp).longVal();
	}
	
	public Datum parse(Evidence ev, String exp) {
		Datum d = null;
		this.data = ev;
		
		try {
			this.ReInit(new java.io.ByteArrayInputStream(exp.getBytes()));
			stack = new java.util.Stack();
			
			this.one_line();
			
			d = (Datum) stack.pop();
		}
		catch (java.util.EmptyStackException e) {
			System.out.println("Stack underflow");
		}
		catch (ParseException e) {
			System.out.println("Parse error: " + e.getMessage());
		}
		catch (TokenMgrError e) {
			System.out.println("Tokenization error: " + e.getMessage());
		}
		finally {
			if (d == null)
				return new Datum(Datum.INVALID);
			else
				return d;
		}
	}
	
	public String parseJSP(Evidence ev, String msg) {
		java.util.StringTokenizer st = new java.util.StringTokenizer(msg,"`",true);
		StringBuffer sb = new StringBuffer();
		String s;
		boolean inside = false;
		
		while(st.hasMoreTokens()) {
			s = st.nextToken();
			if ("`".equals(s)) {
				inside = (inside) ? false : true;
				continue;
			}
			else {
				if (inside) {
					sb.append(StringVal(ev,s));
				}
				else {
					sb.append(s);
				}
			}
		}
		return sb.toString();
	}
}

PARSER_END(Qss)

TOKEN_MGR_DECLS :
{
	private static final void imageReplace(int start, int end, String msg) {
		StringBuffer sb = new StringBuffer();
		String old = image.toString();
		sb.append(old.substring(0,start));
		sb.append(msg);
		sb.append(old.substring(end,old.length()));
		image = sb;
	}
}


MORE :
{
  "\"" : WithinString
| "\'" : WithinCharacter
}

<WithinString> TOKEN :
{
		<STRING_LITERAL: "\""> { Qss.stringToken = image.toString().substring(1,image.length()-1); }: DEFAULT
}

<WithinString> MORE :
{
	"\\n" { imageReplace(image.length()-2,image.length(),"\n"); }
|	"\\r" { imageReplace(image.length()-2,image.length(),"\r"); }
|	"\\\\" { imageReplace(image.length()-2,image.length(),"\\"); }
|	"\\t" { imageReplace(image.length()-2,image.length(),"\t"); }
|	"\\f" { imageReplace(image.length()-2,image.length(),"\f"); }
|	"\\b" { imageReplace(image.length()-2,image.length(),"\b"); }
|	"\\\"" { imageReplace(image.length()-2,image.length(),"\""); }
|	"\\\'" { imageReplace(image.length()-2,image.length(),"\'"); }
|	<~["\n","\r"]> 
}

<WithinCharacter> TOKEN :
{
		<CHARACTER_LITERAL: "\'"> { Qss.stringToken = image.toString().substring(1,image.length()-1); }: DEFAULT
}

<WithinCharacter> MORE :
{
	"\\n" { imageReplace(image.length()-2,image.length(),"\n"); }
|	"\\r" { imageReplace(image.length()-2,image.length(),"\r"); }
|	"\\\\" { imageReplace(image.length()-2,image.length(),"\\"); }
|	"\\t" { imageReplace(image.length()-2,image.length(),"\t"); }
|	"\\f" { imageReplace(image.length()-2,image.length(),"\f"); }
|	"\\b" { imageReplace(image.length()-2,image.length(),"\b"); }
|	"\\\"" { imageReplace(image.length()-2,image.length(),"\""); }
|	"\\\'" { imageReplace(image.length()-2,image.length(),"\'"); }
|	<~["\n","\r"]> 
}

TOKEN : /* OPERATORS */
{
  		< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |	< MODULUS: "%" >
  |	< AND: "&" >
  |	< OR: "|" >
  |	< XOR: "^" >
  |	< NOT: "!" >
  |	< GT: ">" >
  |	< GE: ">=" >
  |	< EQ: "==" >
  |	< NEQ: "!=" >
  |	< LT: "<" >
  |	< LE:	"<=" >
  |	< ANDAND: "&&" >
  |	< OROR: "||" >
  |	< LP: "(" >
  |	< RP: ")" >
  |	< COUNT: "count" >
  |	< LIST:	"list" >
  |	< DESC:	"desc" >
  |	< UNSET: "unset" >
  |	< DOT: "." >
}

SKIP :
{
  " "
| "\t"
| "\r"

}

TOKEN : /* numeric constants */
{
 <INTEGER_LITERAL: <DECIMAL_LITERAL> | <HEX_LITERAL> | <OCTAL_LITERAL> >
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

TOKEN : /* Function names */
{
 	<  ID : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
 |	< EOL: "\n" >
} 

void one_line() : {}
{
	Expression() (<EOL> | <EOF>)
| <EOL>
| <EOF>
}

void Expression() : {}
{
	LOOKAHEAD(2) AssignmentExpression()
	| ConditionalExpression()	
}

void AssignmentExpression(): { Token t; }
{
    (t = <ID>) "=" ConditionalExpression()
    	{
    		Datum d = (Datum) stack.pop();
    		data.set(t.image,d);
    		stack.push(d);
    	}
}

void ConditionalExpression() : {}
{
	LogicalORExpression() ("?" LogicalORExpression() ":" LogicalORExpression()
	{
		Datum c = (Datum) stack.pop();
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.conditional(a,b,c));
	}
	)*
}

void LogicalORExpression() : {}
{
	LogicalANDExpression()	( <OROR> LogicalANDExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.oror(a,b));
	}
	)*
}

void LogicalANDExpression() : {}
{
	InclusiveORExpression() ( <ANDAND> InclusiveORExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.andand(a,b));
	}
	)*
}

void InclusiveORExpression() : {}
{
	ExclusiveORExpression() ( <OR> ExclusiveORExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.or(a,b));
	}
	)*
}

void ExclusiveORExpression() : {}
{
	ANDExpression() ( <XOR> ANDExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.xor(a,b));
	}
	)*
}

void ANDExpression() : {}
{
	EqualityExpression() ( LOOKAHEAD(2) <AND> EqualityExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
		stack.push(DatumMath.and(a,b));
	}
	)*
}

void EqualityExpression() : { Token op; }
{
	RelationalExpression() ( ( <EQ> | <NEQ> ) { op = token; } RelationalExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
	    if ( op.kind == EQ ) {
			  stack.push(DatumMath.eq(a,b));
			}
	    else if (op.kind == NEQ) {
			  stack.push(DatumMath.neq(a,b));
		}
	}	
	)*
}

void RelationalExpression() : { Token op; }
{
	AdditiveExpression() ( ( <LT> | <GT> | <LE> | <GE> ) { op = token; } AdditiveExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
	    switch(op.kind) {
	    	case LT: stack.push(DatumMath.lt(a,b)); break;
	    	case GT: stack.push(DatumMath.gt(a,b)); break;
	    	case LE: stack.push(DatumMath.le(a,b)); break;
	    	case GE: stack.push(DatumMath.ge(a,b)); break;
	   }
	}
	)*
}

void AdditiveExpression() : { Token op; }
{
	MultiplicativeExpression() ( LOOKAHEAD(2) ( <PLUS> | <MINUS> | <DOT> ) { op = token;} MultiplicativeExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
	    if ( op.kind == PLUS ) {
			  stack.push(DatumMath.add(a,b));
			}
	    else if (op.kind == MINUS) {
			stack.push(DatumMath.subtract(a,b));
		}
		else if (op.kind == DOT) {
			stack.push(DatumMath.concat(a,b));
		}
	}
	)*
}

void MultiplicativeExpression() : { Token op; }
{
	UnaryExpression() ( LOOKAHEAD(2) ( <MULTIPLY> | <DIVIDE> ) { op = token; } UnaryExpression() 
	{
		Datum b = (Datum) stack.pop();
		Datum a = (Datum) stack.pop();
	    if ( op.kind == MULTIPLY ) {
			  stack.push(DatumMath.multiply(a,b));
			}
	    else if (op.kind == DIVIDE) {
	    	stack.push(DatumMath.divide(a,b));
		}
	}
	)*
}

void UnaryExpression() : { Token op; }
{
	(op = UnaryOperator()) PrimaryExpression() 
	{ 
		switch(op.kind) {
			default:
				break;
			case MINUS: {
				stack.push(DatumMath.neg((Datum) stack.pop()));
	    		break;
	    	}
	    	case NOT: {
	    		stack.push(DatumMath.not((Datum) stack.pop()));
	    		break;	
	    	}
	    }
	}
	| PrimaryExpression()
}

Token UnaryOperator() : {}
{
	( <PLUS> | <MINUS> | <NOT> ) { return token; }
}

void Count() : { long total; }
{
	<COUNT> 
		<LP> 
			(total = TruthTestList()) 
		<RP> 
		{ stack.push(new Datum(total)); }
}

void StringList(): { java.util.Vector v = new java.util.Vector(); }
{
	<LIST> <LP> 
		Expression() {v.addElement(stack.pop());}
		( "," (Expression()) {v.addElement(stack.pop());} )*
		<RP>
	{
		StringBuffer sb = new StringBuffer();
		
		/* Remove null strings from list */
		for (int i=0;i<v.size();) {
			if (((Datum) v.elementAt(i)).StringVal().length() == 0) {
				v.removeElementAt(i);
			}
			else {
				++i;
			}
		}
		
		for (int i=0;i<v.size();++i) {
			if (i > 0) {
				if (i < (v.size()-1)) {
					sb.append(", ");
				}
				else {
					sb.append(" and ");
				}
			}
			sb.append(((Datum) v.elementAt(i)).StringVal());
		}
		stack.push(new Datum(sb.toString()));
	}
}

void PrimaryExpression() : {}
{
	Constant() |
	Count() |
	StringList() |
	Description() |
	Unset() |
	Variable() |
	<LP> Expression() <RP>
}

long TruthTestList() : { long count=0; boolean b;}
{
	(b = TruthTest()) { if (b) ++count; } ( "," (b = TruthTest()) { if (b) ++count; })* { return count; }
}

boolean TruthTest() : {}
{
	Expression() {
		try {
			return ((Datum) stack.pop()).booleanVal();
		} catch (java.util.EmptyStackException e) { 
			System.out.println(e.getMessage());
		 }
		return false;
	}
}

void Constant() : { Token t; }
{
	((t = <INTEGER_LITERAL>) | (t = <FLOATING_POINT_LITERAL>))
	{   
		stack.push(new Datum(t.image));
	}
|	(<STRING_LITERAL> | <CHARACTER_LITERAL>)
	{
		stack.push(new Datum(stringToken));
	}
	
}

void Description() : { Token t; }
{
	<DESC> <LP> (t = <ID>) <RP> 
	{
		if (data.containsKey(t.image)) {
			try {
				Node node = data.getNode(t.image);
				stack.push(new Datum(node.getDescription()));
			}
			catch (Exception e) {
				stack.push(new Datum(Datum.INVALID));
			}
		}
		else {
			stack.push(new Datum(Datum.INVALID));
		}
	}
}

void Unset() : { Token t; }
{
	<UNSET> <LP> (t = <ID>) <RP>
	{
		data.unset(t.image);
		stack.push(new Datum(Datum.INVALID));
	}
}

void Variable() : {}
{
	<ID>
	{   
		if (data.containsKey(token.image)) {
			Datum d = data.getDatum(token.image);
			stack.push(d);
		}
		else {
			System.out.println("Variable " + token.image + " undefined");
			stack.push(new Datum(Datum.INVALID));
		}
	}
}
